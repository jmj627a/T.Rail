

1. 최적화

-Find() 같이 씬 전체 검색 함수 X
- 오브젝트를 실시간으로 파괴하는 것봗, 비활성화 하는게 비용이 더 싸게 먹힘

** 오브젝트 풀링 반드시 쓰기
실시간으로 많이 찍어내고 파괴하는 오브젝트는 오브젝트 풀링으로 관리.

- string은 사용하는 만큼 생성된다.
string message = "Hello" + "World"; 같이 연결하는 부분 주의
실제로는 3개의 string이 메모에 할당된다.
StringBuilder나 String.Format()을 사용

-클래스와 구조체의 차이점!
클래스는 Pass by Reference, 구조체는 Pass by Value로 동장.
값을 전달할 때 class는 레퍼런스가 할당되고, struct는 복제본을 전달

struct -> 단순 데이터 컨테이너용으로 50개의 struct를 사용해보면 struct는 메모리를 많이 사용.
구조체는 스택에 할당이되고, 자신을 호출한 함수가 종료되면 즉시 사라진다.
그러나 단일 struct 오브젝트의 크기가 너무 커지거나, 너무 긴 리스트에 넣고 쓰면, 복사하는 시간이 길어진다. 이때 class 형보다 처리 시간이 더 길어질 수 있다.
그러므로 변수가 2-3개 뿐인 단순한 데이터 컨테이너라면 struct를 사용하는 게 빠르다. 일반적인 경우는 class를 쓰는 것이 좋다.


- Debug.Log()는 의외로 성능 저하의 주범
C# 조건 속성을 이용하기. 
https://msdn.microsoft.com/en-us/library/4xssyw96(v=vs.90).aspx

클래스 내부에 Conditional 속성이 저장된 static void 함수를 추가
1. 만약 Conditional에 따라오는 심볼이 정의됐다면 static 함수는 존재한다.
2. 중요한것은 static 함수 뿐만이 아니라, 그것을 호출하는 부분까지 모조리빌드에서 빠져나가므로 매우 간편하다.
조건 속성으로 묶인 디버그 함수를 사용한 코드들은 빌드시에 처음부터 존재하지도 않은 것이 된다.
다만 유니티 콘솔창에서 로그를 더블 클릭하면, 오류가 난 지점이 아닌 디버그를 랩핑한 코드로 이동하는 사소한 불편이 있다.

using System;
using System.Diagnostics;

public class DebugX
{
    [Conditional("UnityEditor")]
    public static void Log(string msg)
    {
        Debug.Log(msg);
    }
}

// PlayerSettings > Scripting Define Symbols 에 ACTIVE_DEBUG 가 없다면 아래 코드 호출은 아예 처음부터 없었던 것으로 처리됩니다.
DebugX.Log( "Hello world" );



- 오디오 매니저 (프로젝트 세팅에 있음)
스테레오 사운드가 필요없다면 오디오 매니저에서 스피커 모드를 Mono나 Raw로 

- 로드타입

 = 메모리 많이 먹고 빠릿함 vs 메모리 적게 먹고 오버헤드
	ㅇ Decompress On Load
	미리 압축을 해제해서 메모리에 적재하기에, 플레이 하는 순간에 오버헤드가 생기지 않는다. 적은 용량의 효과음에 사용하는 것이 이득. 압축을 미리 메모리에 풀기 때문에 메모리를 많이 먹기 때문이다.
	ㅇ Compress On Memory
	메모리에 로드할때는 압축되어 있다가 재생시 압축을 해제. 플레이하는 순간에 압축을 푸는 과정이 생기기에, 오버헤드가 생길 수 있다. 



- UGUI 오버헤드 관리
하나의 캔버스에 모든 UI 요소를 넣는 것이 꼭 좋은 것은 아니다.
캔버스에서 어떤 UI 요소의 스프라이트가 동적으로 변할 때, 캔버스에 있는 전체 요소들도 동시에 갱신된다.
즉 하나가 변하면, 같은 캔버스에 다른 친구들도 같이 갱신된다.
따라서 서로 같은 타이밍에 내용이 (텍스트나 이미지가) 바뀌는 오브젝트끼리 같은 캔버스로 묶으면 성능에 좋다.
그러나 개발자가 직관적으로 편집하기 좋게 하이라키에 배치하는 것도 고려해야 하니, 어디까지나 케바케

- 폰트
 완성형 한글의 모든 글자를 메모리에 집어넣는 메모리 빌런이 되고 싶지 않으면 Dynamic을 사용. 폰트를 임포트할 때 기본값으로 Dynamic이 지정된다.

- Resource 폴더는 안쓸 수 있다면 최대한 쓰지 말자.
여기 들어가는 요소들은 실제 사용되든 사용되지 않든 빌드에 무조건 포함되고 메모리에 적재된다.

- 박싱과 언박싱은 부하가 크다
- 삼각함수의 값은 상수로 저장하고 사용하는 것이 좋다.
- 문자열은 readonly 혹은 const 키워드를 사용하여, 가비지 컬렉션으로부터 벗어나도록 한다.


    << 가비지 컬렉터 >>
	가비지 컬렉터(GC)는 언제 일어날지 모른다.
	ㅇ Mono의 동적 메모리 관리 때문에, 메모리 해제를 위해 GC가 자동 호출 된다.
	ㅇ GC 가 일어나면, 게임이 멈추는 현상이 발생하게 된다.
	ㅇ 동적 메모리 해제가 가능한 일어나지 않도록 하는 것이 GC 관리의 핵심

	* GC에게 먹이를 주지 마시오 *
	1) foreach대신에 for문 사용 (일반 array에 한해서)
	2) 문자열 병합은 StringBuilder사용 
		일반 string+string을 쓰면 임시 문자열이 생성
		StringBuilder.Append() 함수를 사용해서 병합
	3) 태그 비교에는 compareTag() 사용
		객체의 tag 프로퍼티를 호출하는 것은 추가 메모리를 할당하고 복사한다.
	4) 데이터 타입에는 class 대신 구조체 사용
		구조체는 GC에 들어가지 않고 stack에 할당되기 때문에 호출이 끝나면 소멸
	5) 임시객체들을 만들어내는 API들을 조심한다 (?)
		ex) GetComponents<T>, Mesh.Vertices, Camera.allCameras, etc...


     << 오브젝트풀링 >>
	ㅇ 오브젝트(or 프리팹)의 동적 생성과 해제는 부하가 크다.
	ㅇ 오브젝트가 해제되면 언젠가는 GC가 동작하여 정리 = 렉 생김
	ㅇ 오브젝트를 풀을 만들어 미리 많이 만들어 놓고, 활성화/ 비활성화로 사용
	ㅇ 풀에서 가져와서 사용하고, 사용이 끝나면 비활성화 상태로 풀에 반환

	1) 풀에 오브젝트를 일정개수 미리 만든다. (풀링 - 실시간 생성으로 인한 부하를 줄인다)
	2) 풀에서 오브젝트를 가져와서 사용한다
	3) 사용이 끝나면 파괴하지 않고, 풀에 다시 넣는다.
	4) 필요할때 다시 꺼내 재사용한다.

	- 오브젝트 풀링 매니저 = 싱글톤
	- 임의의 오브젝트를 복수 등록 가능
	- 오브젝트 풀의 기본 개수를 설정 가능
	- 동적 증가 기능
	- 사용중 / 미사용 리스트를 구현하여 최적화
	


    << 최적화를 위한 병목 파악 >>

1. CPU 
너무 많은 DP CALL / 복잡한 스크립트나 물리 연산

2. Vertex Processing
너무 많은 버텍스들 / 버텍스당 너무 많은 연산(버텍스 셰이더)

3. Fragment Processing
너무 많은 픽셀, 오버 드로우(OverDraw) / 프래그먼트 당 너무 많은 연산 (프래그먼트 셰이더 / 픽셀 셰이더)

4. Band Width
크고, 압축되지 않은 텍스쳐 / 고해상도 프레임 버퍼

     << 쉐이더 >>
	1) 복잡한 수학 연산들은 고연산이다.
		ㅇ pow, exp, log, cos, sin, tan같은 수학 함수들..
		ㅇ 픽셀별과 같은 연산을 하나 이상 사용하지 않는 것이 좋다.
		ㅇ 텍스쳐 룩업테이블을 만들어서 사용하는 방법도 좋다. (?)
		ㅇ 기본적인 연산보다는 최적화시키고 간략화시킨 공식들을 찾아서 사용할 수 있다.
	2) 실수 연산
		ㅇ float : 32 bit - 버텍스 변환에 사용. 아주 느린성능 (픽셀 셰이더에서의 사용은 피함)
		ㅇ Half : 16bit - 텍스쳐 uv에 적합. 대략 2배 빠름
		ㅇ fixed : 10bit - 컬러, 라이트 계산과 같은 고성능 연산에 적합. 대략 4배빠름 